
<!DOCTYPE html>
<html lang="sk">
<head>
<meta charset="utf-8"/>
<title>Hra V1 - multitouch fixed</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<style>
  body { margin: 0; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
  canvas { border: 1px solid black; touch-action: none; display: block; }
  #message {
  display: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-weight: bold;
  color: white;
  background-color: rgba(0,0,0,0.7);
  padding: 16px 28px;
  border-radius: 16px;
  z-index: 100;
  text-align: center;
  max-width: 80vw;           /* širšie! */
  width: 80vw;               /* fixná šírka 80% viewportu (alebo to daj cez JS z canvasu) */
  /* odstránený overflow-y: auto; */
  box-sizing: border-box;
  word-break: break-word;
}
  #restartBtn {
    font-size: 24px;
    padding: 10px 20px;
    background-color: darkgreen;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    margin: 20px;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="message">Victory, Katarina!<br>
  <br>
  Because of you,<br>
  even this game is<br>
  something special,<br>and even the smallest<br>
  victories make<br>so much more sense.<br>
</div>
<button id="restartBtn">AGAIN</button>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const messageDiv = document.getElementById("message");
const restartBtn = document.getElementById("restartBtn");

const rows = 5;
const cols = 5;
let tileSize;
let tiles = [];
let animations = [];
let isMouseDown = false;
let selected = null;
let draggingTile = null;
let activeTouchId = null;
let lastMX = null, lastMY = null;
const colors = ["green", "blue", "red", "gray"];

function resizeCanvas() {
  const shorterSide = Math.min(window.innerWidth, window.innerHeight * 0.9);
  canvas.width = shorterSide;
  canvas.height = shorterSide;
  tileSize = canvas.width / cols;
    // Dynamické prispôsobenie fontu správy veľkosti canvasu
  const messageFontSize = Math.round(canvas.width * 0.07); // cca 7% šírky
  messageDiv.style.fontSize = messageFontSize + "px";
  draw();
}

function createTiles() {
  const totalTiles = rows * cols;
  const minPerColor = 3;
  const baseColors = ["green", "blue", "red"];
  let positions = [];
  for (let y = 0; y < rows; y++)
    for (let x = 0; x < cols; x++)
      positions.push([y, x]);

  // Rohové "ramená" - zakázané dvojice
  const forbiddenPairs = [
    // ľavý horný roh
    [[1,0], [0,1]],
    // pravý horný roh
    [[1,cols-1], [0,cols-2]],
    // ľavý dolný roh
    [[rows-2,0], [rows-1,1]],
    // pravý dolný roh
    [[rows-2,cols-1], [rows-1,cols-2]],
  ];

  function isForbiddenPair(a, b) {
    return forbiddenPairs.some(
      ([p1, p2]) =>
        ((a[0] === p1[0] && a[1] === p1[1] && b[0] === p2[0] && b[1] === p2[1]) ||
         (b[0] === p1[0] && b[1] === p1[1] && a[0] === p2[0] && a[1] === p2[1]))
    );
  }

  let grayA, grayB;
  while (true) {
    // Zamiešame všetky možné pozície
    const shuffled = positions.slice().sort(() => Math.random() - 0.5);
    grayA = shuffled[0];
    grayB = shuffled.find(p => p[0] !== grayA[0] || p[1] !== grayA[1]);
    if (!isForbiddenPair(grayA, grayB)) break;
    // ak je zakázaná dvojica, skúšame znova
  }

  // Naplníme pole najprv sivými, potom ostatnými farbami
  let tileList = [];
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if ((y === grayA[0] && x === grayA[1]) || (y === grayB[0] && x === grayB[1])) {
        tileList.push({ color: "gray" });
      } else {
        tileList.push(null);
      }
    }
  }

  // Každá z ostatných farieb aspoň 3x
  let leftTiles = [];
  for (const color of baseColors) {
    for (let i = 0; i < minPerColor; i++) {
      leftTiles.push({ color });
    }
  }
  while (leftTiles.length < totalTiles - 2) {
    const color = baseColors[Math.floor(Math.random() * baseColors.length)];
    leftTiles.push({ color });
  }

  // Zamiešame farby
  for (let i = leftTiles.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [leftTiles[i], leftTiles[j]] = [leftTiles[j], leftTiles[i]];
  }

  // Doplň zvyšné políčka
  let idx = 0;
  for (let i = 0; i < tileList.length; i++) {
    if (tileList[i] === null) {
      tileList[i] = leftTiles[idx++];
    }
  }

  // Rozdelenie na 2D pole
  tiles = [];
  for (let y = 0; y < rows; y++) {
    const row = [];
    for (let x = 0; x < cols; x++) {
      row.push(tileList[y * cols + x]);
    }
    tiles.push(row);
  }
}

function drawDraggedTile(mx, my) {
  if (!draggingTile || !isMouseDown) return;
  const half = tileSize / 2;
  const x = Math.max(half, Math.min(mx, canvas.width - half)) - half;
  const y = Math.max(half, Math.min(my, canvas.height - half)) - half;
  ctx.save();
  ctx.globalAlpha = 0.92;
  ctx.translate(x, y);
  ctx.shadowColor = "rgba(0,0,0,0.5)";
  ctx.shadowBlur = 12;
  
if (images[draggingTile.color] && images[draggingTile.color].complete) {
  ctx.drawImage(images[draggingTile.color], 0, 0, tileSize, tileSize);
} else {
  ctx.fillStyle = draggingTile.color;
  ctx.fillRect(0, 0, tileSize, tileSize);
}

  ctx.restore();
}


function drawAnimatedTiles() {
  const now = performance.now();
  animations = animations.filter(anim => {
    const t = Math.min(1, (now - anim.start) / anim.duration);
    const x = anim.from.col * (1 - t) + anim.to.col * t;
    const y = anim.from.row * (1 - t) + anim.to.row * t;

    // Vždy vykresľuj JPG dlaždicu
    ctx.drawImage(images[anim.color], x * tileSize, y * tileSize, tileSize, tileSize);

    return t < 1;
  });
  if (animations.length) requestAnimationFrame(draw);
}

function draw(mx = null, my = null) {
  drawTiles();
  if (mx !== null && my !== null) drawDraggedTile(mx, my);
  drawAnimatedTiles();
}

function getCoords(px, py) {
  const col = Math.floor(px / tileSize);
  const row = Math.floor(py / tileSize);
  return col >= 0 && col < cols && row >= 0 && row < rows ? { col, row } : null;
}


function isGrayAt(r, c) {
  const t = tiles[r][c];
  return t && t.color === "gray";
}

// neighbors (4-dir), allow moving through non-gray tiles (occupied allowed)
function _nb(pos) {
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  const out = [];
  for (const [dx,dy] of dirs) {
    const nc = pos.col + dx, nr = pos.row + dy;
    if (nc>=0 && nc<cols && nr>=0 && nr<rows) {
      if (!isGrayAt(nr, nc)) out.push({col:nc, row:nr});
    }
  }
  return out;
}

function _reconstruct(came, key) {
  const path = [];
  while (key) {
    const [r,c] = key.split(',').map(Number);
    path.push({row:r, col:c});
    key = came.get(key);
  }
  return path.reverse();
}

// BFS shortest path avoiding gray

function isGrayAt(r, c) {
  const t = tiles[r][c];
  return t && t.color === "gray";
}


function isGrayAt(r, c) {
  const t = tiles[r][c];
  return t && t.color === "gray";
}

// A* with: 
// - Manhattan heuristic
// - axis preference toward drag direction
// - when dragging horizontally and detouring vertically, prefer going UP first (row-1) -> "gravity from above"

function isGrayAt(r, c) {
  const t = tiles[r][c];
  return t && t.color === "gray";
}

// Find first gray tile encountered horizontally along given row between c0->c1 (inclusive)
function findBlockingGrayHorizontal(row, c0, c1) {
  const step = c1 >= c0 ? 1 : -1;
  for (let c = c0; c !== c1 + step; c += step) {
    if (c >= 0 && c < cols && row >= 0 && row < rows) {
      if (isGrayAt(row, c)) return { row, col: c };
    }
  }
  return null;
}

// Find first gray tile encountered vertically along given col between r0->r1 (inclusive)
function findBlockingGrayVertical(col, r0, r1) {
  const step = r1 >= r0 ? 1 : -1;
  for (let r = r0; r !== r1 + step; r += step) {
    if (r >= 0 && r < rows && col >= 0 && col < cols) {
      if (isGrayAt(r, col)) return { row: r, col: col };
    }
  }
  return null;
}

function getPath(from, to) {
  const start = {row: from.row, col: from.col};
  const goal  = {row: to.row,   col: to.col};
  if (start.row === goal.row && start.col === goal.col) return [start];

  // Drag analysis
  const dx = Math.abs(goal.col - start.col);
  const dy = Math.abs(goal.row - start.row);
  const horizontalDrag = dx > dy;
  const preferVertical = !horizontalDrag;

  // Determine side preference near the FIRST blocking gray between start and goal
  let vertPref = 0;   // -1 = up, +1 = down
  let horizPref = 0;  // -1 = left, +1 = right

  if (horizontalDrag) {
    const blk = findBlockingGrayHorizontal(start.row, start.col, goal.col);
    if (blk && typeof lastMY === 'number') {
      const centerY = (blk.row + 0.5) * tileSize;
      vertPref = (lastMY < centerY) ? -1 : 1; // if pointer is in upper half -> go UP, else DOWN
    }
  } else {
    const blk = findBlockingGrayVertical(start.col, start.row, goal.row);
    if (blk && typeof lastMX === 'number') {
      const centerX = (blk.col + 0.5) * tileSize;
      horizPref = (lastMX < centerX) ? -1 : 1; // if pointer is in left half -> go LEFT, else RIGHT
    }
  }

  function key(p){ return p.row + "," + p.col; }
  function h(p){
    const ddx = Math.abs(p.col - goal.col);
    const ddy = Math.abs(p.row - goal.row);
    const bias = preferVertical ? (p.col !== goal.col ? 0.001 : 0) : (p.row !== goal.row ? 0.001 : 0);
    return ddx + ddy + bias;
  }
  function neighbors(p){
    const out = [];
    const dirs = [
      {dx:  1, dy:  0}, // right
      {dx: -1, dy:  0}, // left
      {dx:  0, dy: -1}, // up
      {dx:  0, dy:  1}  // down
    ];
    for (const d of dirs){
      const nc = p.col + d.dx, nr = p.row + d.dy;
      if (nc>=0 && nc<cols && nr>=0 && nr<rows && !isGrayAt(nr,nc)){
        out.push({row: nr, col: nc, dx: d.dx, dy: d.dy});
      }
    }
    // Sort neighbors for "natural" preference:
    out.sort((a,b)=>{
      // 0) Prefer main-axis steps first
      const aMain = preferVertical ? Math.abs(a.dy) : Math.abs(a.dx);
      const bMain = preferVertical ? Math.abs(b.dy) : Math.abs(b.dx);
      if (aMain !== bMain) return bMain - aMain;

      // 1) If horizontal drag and both moves are vertical (detours), honor vertPref
      if (horizontalDrag && vertPref !== 0) {
        const aFav = (a.dy === vertPref) ? 1 : 0;
        const bFav = (b.dy === vertPref) ? 1 : 0;
        if (aFav !== bFav) return bFav - aFav;
      }
      // 2) If vertical drag and both moves are horizontal (detours), honor horizPref
      if (!horizontalDrag && horizPref !== 0) {
        const aFav = (a.dx === horizPref) ? 1 : 0;
        const bFav = (b.dx === horizPref) ? 1 : 0;
        if (aFav !== bFav) return bFav - aFav;
      }
      // 3) Fallback: closer to goal first
      const ad = Math.abs(a.col - goal.col) + Math.abs(a.row - goal.row);
      const bd = Math.abs(b.col - goal.col) + Math.abs(b.row - goal.row);
      return ad - bd;
    });
    return out;
  }
  function reconstruct(came, curK){
    const path = [];
    while (curK){
      const [r,c] = curK.split(',').map(Number);
      path.push({row:r, col:c});
      curK = came.get(curK);
    }
    return path.reverse();
  }

  // A*
  const open = new Set();
  const cameFrom = new Map();
  const gScore = new Map();
  const fScore = new Map();
  const nodes = new Map();

  const sKey = key(start);
  open.add(sKey);
  gScore.set(sKey, 0);
  fScore.set(sKey, h(start));
  nodes.set(sKey, start);

  while (open.size){
    // lowest fScore
    let bestKey = null, bestNode = null, best = Infinity;
    for (const k of open){
      const fs = fScore.get(k) ?? Infinity;
      if (fs < best){ best = fs; bestKey = k; bestNode = nodes.get(k); }
    }

    if (bestNode.row === goal.row && bestNode.col === goal.col){
      return reconstruct(cameFrom, bestKey);
    }

    open.delete(bestKey);
    for (const nb of neighbors(bestNode)){
      const nk = key(nb);
      nodes.set(nk, {row: nb.row, col: nb.col});
      const tentativeG = (gScore.get(bestKey) ?? Infinity) + 1;
      if (tentativeG < (gScore.get(nk) ?? Infinity)){
        cameFrom.set(nk, bestKey);
        gScore.set(nk, tentativeG);
        fScore.set(nk, tentativeG + h(nb));
        open.add(nk);
      }
    }
  }

  return [start];
}





function startInteraction(mx, my) {
  const coord = getCoords(mx, my);
  if (!coord) return;
  const hoveredTile = tiles[coord.row][coord.col];const tile = tiles[coord.row][coord.col];
  if (tile.color === "gray") return;
  isMouseDown = true;
  selected = coord;
  draggingTile = tiles[selected.row][selected.col];
  tiles[selected.row][selected.col] = null;
  draw(mx, my);
}

function moveInteraction(mx, my) {
  if (!isMouseDown || !draggingTile) return;
  lastMX = mx; lastMY = my;
  const current = getCoords(mx, my);
  if (!current) {
    endInteraction();
    return;
  }
  const path = getPath(selected, current);
  for (const step of path) {
  if (!tiles[step.row][step.col]) continue;
  const currentTile = tiles[step.row][step.col];
  if (currentTile.color === "gray") continue;

  animations.push({
    from: { ...step },
    to: { ...selected },
    color: currentTile.color,
    start: performance.now(),
    duration: 75
  });

  tiles[selected.row][selected.col] = currentTile;
  selected = { ...step };
}
  if (selected) {
    tiles[selected.row][selected.col] = null;
  }
  draw(mx, my);
}

function endInteraction() {
  if (draggingTile && selected) tiles[selected.row][selected.col] = draggingTile;
  isMouseDown = false;
  draggingTile = null;
  selected = null;
  draw();
  checkRegions();
}

function checkRegions() {
  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
  const colorRegions = Object.fromEntries(colors.map(c => [c, 0]));

  function flood(x, y, col) {
    const q = [[x, y]];
    visited[y][x] = true;
    while (q.length) {
      const [cx, cy] = q.pop();
      [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy]) => {
        const nx = cx + dx, ny = cy + dy;
        if (nx>=0&&nx<cols&&ny>=0&&ny<rows&&!visited[ny][nx]&&tiles[ny][nx]&&tiles[ny][nx].color===col) {
          visited[ny][nx]=true; q.push([nx,ny]);
        }
      });
    }
  }

  for (let y=0; y<rows; y++) {
    for (let x=0; x<cols; x++) {
      if (!visited[y][x] && tiles[y][x]) {
        const col = tiles[y][x].color;
        if (colors.includes(col)) {
          colorRegions[col] += 1;
          flood(x, y, col);
        }
      }
    }
  }

  const baseColors = ["green", "blue", "red"];
  const win = baseColors.every(color => colorRegions[color] === 1) &&
              Object.entries(colorRegions).every(([color, count]) =>
                baseColors.includes(color) ? count === 1 : true);
  if (win) {
    messageDiv.style.display = "block";
  }
}

canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  startInteraction(e.clientX - rect.left, e.clientY - rect.top);
});
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  moveInteraction(e.clientX - rect.left, e.clientY - rect.top);
});
canvas.addEventListener('mouseup', endInteraction);
canvas.addEventListener('mouseleave', endInteraction);

canvas.addEventListener('touchstart', e => {
  if (activeTouchId !== null) {
    // ignore additional touches during active drag
    return;
  }
  const touch = e.changedTouches[0];
  activeTouchId = touch.identifier;
  const rect = canvas.getBoundingClientRect();
  startInteraction(touch.clientX - rect.left, touch.clientY - rect.top);
});

canvas.addEventListener('touchmove', e => {
  const touch = Array.from(e.touches).find(t => t.identifier === activeTouchId);
  if (!touch) return;
  const rect = canvas.getBoundingClientRect();
  moveInteraction(touch.clientX - rect.left, touch.clientY - rect.top);
});

canvas.addEventListener('touchend', e => {
  if (Array.from(e.changedTouches).some(t => t.identifier === activeTouchId)) {
    endInteraction();
    activeTouchId = null;
  }
});

restartBtn.addEventListener("click", () => {
  messageDiv.style.display = "none";
  createTiles();
  draw();
});

window.addEventListener("load", () => {
  createTiles();
  resizeCanvas();
});

function fixBlockedTiles() {
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const tile = tiles[row][col];

      const up = row > 0 ? tiles[row - 1][col] : null;
      const down = row < rows - 1 ? tiles[row + 1][col] : null;
      const left = col > 0 ? tiles[row][col - 1] : null;
      const right = col < cols - 1 ? tiles[row][col + 1] : null;

      const neighbors = [up, down, left, right].filter(n => n);

      if (grays.length === neighbors.length) {
        // Náhodne jednu sivú nahradíme farbou aktuálnej dlaždice
        const candidates = [];

        if (candidates.length > 0) {
          const [r, c] = candidates[Math.floor(Math.random() * candidates.length)];
          tiles[r][c].color = tile.color;
        }
      }
    }
  }
}



// Načítanie obrázka pre modrú dlaždicu

const blueImage = new Image();
blueImage.src = "Color02.jpg";
const redImage = new Image();
redImage.src = "Color03.jpg";
const greenImage = new Image();
greenImage.src = "Color01.jpg";
const grayImage = new Image();
grayImage.src = "Color00.jpg";

const images = {
  blue: blueImage,
  red: redImage,
  green: greenImage,
  gray: grayImage
};


// Funkcia na vykreslenie dlaždíc (s kontrolou načítania obrázka)
function drawTiles() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const tile = tiles[row][col];
      const x = col * tileSize;
      const y = row * tileSize;

      if (tile === null) continue;

      
if (images[tile.color] && images[tile.color].complete) {
  ctx.drawImage(images[tile.color], x, y, tileSize, tileSize);
} else {
  ctx.fillStyle = tile.color;
  ctx.fillRect(x, y, tileSize, tileSize);
}

    }
  }
}
</script>

</body>
</html>